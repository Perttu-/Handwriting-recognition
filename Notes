 
Research matlab image processing functions and the difference in functionality with different amount of arguments. Try to understand it well.

Program example matlab program which does some preprocessing. Robust as possible: resizing, histogram equalization, binarization etc. Work for many file types and colors.

read and merit and demerit each method:
First International Conference on Emerging Trends in Engineering and Technology
A Survey of Methods and Strategies for Feature Extraction in
Handwritten Script Identification

-----------------------------------------------------------------------------------------

For regular photograph resolution should be preferably so that the stroke width is more than 3 px.
(for smaller resolution it is dificult also for humans to recognize the text)

Constraints:
-resolution & text size!
-Arguments for the binarization and opening

Preprocessing functionality:
-Noise reduction 
-Binarization (Done with sauvola method)
-Region analysis
-Cropping


optimal values for 5 first images in iam database (handwriting part only)
    p.wienerFilterSize = 15;
    p.sauvolaNeighbourhoodSize = 180;
    p.sauvolaThreshold = 0.3;
    p.morphClosingDiscSize = 3;
    p.strokeWidthThreshold = 0.6;
    p.skewCorrection = 0;
    aoiXExpansionAmount = 40;
    aoiYExpansionAmount = 60;
    areaRatioThreshold = 0.004;
    rlsaRowThreshold = 300;
    rlsaWordHorizontalThreshold = 30;
    rlsaWordVerticalThreshold = 30;

pasting this here dont mind me

    
    %bounding box method
%     for ii=1:aoi
%         img = imageStruct(ii).Image;
%         bboxes = regionprops(img,'BoundingBox');
%         expandedBBoxes = expandBBoxes(img,...
%                                       bboxes,...
%                                       wordXExpansionAmount,...
%                                       wordYExpansionAmount);
%         [wordBBoxes, ~] = combineOverlappingBoxes(expandedBBoxes, 0);
%         imageStruct(ii).BoundingBox = wordBBoxes;
%         
%     end
    
    %% word detection
%     %searching for spaces
%     %doesn't work for one word rows with separated characters
%     for ii=1:length(imageStruct)
%         spaces = imageStruct(ii).Space;
%         if ~isempty(spaces)
%              spaceLengths = spaces(:,2) - spaces(:,1);
% %             totalSpaceLength = sum(spaceLengths);
% %             spaceRatio = spaceLengths/totalSpaceLength;
% %             spaces((spaceRatio<spaceRatioThreshold),:)=[];
%             spaces(spaceLengths<spaceThreshold,:)=[];
%             imageStruct(ii).Space = spaces;
%         end
%     end
  
    %toc

    %% visualization
        
    
%     figure();
%     visualizeBBoxes(aoiStruct(1).Image, aoiStruct(1).RlsaBBoxes);
%       visualizeLayout(p.originalImage,layoutStruct);
%       figure();
%       visualizeBBoxes(aoiStruct(2).RowStruct(1).RowImage, aoiStruct(2).RowStruct(1).WordBoxes, 'g');
%     figure();
%     visualizeBBoxes(p.finalImage, combinedBBoxes);
    %figure(),imshow(imageStruct(1).Image),hold on, visboundaries(bwboundaries(imageStruct(1).RlsaImage,8,'noholes'));
    %visualizeImgStruct(imageStruct,[],0);



houg vis

    
%     imshow(image);
%     hold on;
%     x(1)=0;
%     y(1)=0;
%     x = zeros(numel(thetas)*numel(rhos),2);
%     y = zeros(numel(thetas)*numel(rhos),2);
%     xp = x;
%     yp = y;

    
%     for t = thetas
%         for r = rhos
%             x(2)=x(1)+r*cosd(t);
%             y(2)=y(1)+r*sind(t);
%             %plot(x(2),y(2),'r*');
%             %line(x,y);
%             t2 = t+90;
%             
% 
%         end
%     end

--------


    while 1
        [maxValue, maxIndex]=max(tmpAcc(:));
        [maxIRow, maxICol] = ind2sub(size(tmpAcc),maxIndex);
        [height,width]=size(tmpAcc);
        voterPoints = cell2mat(voterCoordCell(maxIRow-5:maxIRow+5,maxICol));
        voterNumbers = cell2mat(voterNumberCell(maxIRow-5:maxIRow+5,maxICol));
        voterAmount = length(voterPoints);
%         voterNumbers = zeros(1,voterAmount);
        lineNumber = 1;
        objectsInLine = [];
%         for ii = 1:voterAmount
%             voterNumbers(ii) = centroidImg(voterPoints(ii,1),voterPoints(ii,2));
%         end
        
        for ii = 1:length(subset1)
            objPartsInRow=sum(voterNumbers(:) == subset1(ii).Index);
            piecesAmount=subset1(ii).PiecesAmount;
            if objPartsInRow > 0 && piecesAmount/objPartsInRow >= 0.5
                objInRow = subset1(ii).Index;
                objectsInLine(end+1) = objInRow;
                %remove from voterCell the points assigned to a row 
                
            end
        end
        
        if contribution < n1
            break
        end
    end
------

%     figure(),
%     imshow(imadjust(mat2gray(accArr)),'XData',thetas,'YData',rhos,...
%        'InitialMagnification','fit');
%     title('Hough Transform');
%     xlabel('\theta'), ylabel('\rho');
%     axis on, axis normal;
%     colormap(hot);
%     drawnow


        %rewrite this
%         for ii = 1:size(cPoints,1) 
%             p = cPoints(ii,:);
%             newComponentId = centroidImg(p(1),p(2));
%             pY = p(1);
%             foundLineCentYs = sort(foundLineCentYs);
%             [minDist,minIdx]=min(abs(foundLineCentYs-pY));
%             closestLineY = foundLineCentYs(minIdx);
%             distance = pY-closestLineY;
%             absDist = abs(distance);
% 
%             %Using previously found line if within the margin distance from
%             %it. Otherwise assigning a new position to line which is 
%             %average distance apart from closest line.
%             if absDist < sameLineMargin*avgDistance
%                 %Close enought to be categorized into existing line.
%                 locInStruct = find([candLineStruct(:).YLoc]==closestLineY);
%                 if locInStruct
%                     %If the existing line is one of the previously detected
%                     %new lines, we use that.
%                     candLineStruct(locInStruct).Indices = [candLineStruct(locInStruct).Indices,...
%                                                            newComponentId];
%                 else
%                     candLineStruct(newIndex).YLoc = pY;
%                     candLineStruct(newIndex).Indices = newComponentId;
%                     candLineStruct(newIndex).OldLine = minIdx;
%                     foundLineCentYs(end+1) = pY;
%                     lineEndPoints(end+1,:) = [0,pY,imgWidth,pY];
%                     newIndex = newIndex+1;
%                 end
%             else
%                 if absDist > closeAvgDistMargin*avgDistance
%                     %Close enough to other lines to be a new line.
%                     candLineStruct(newIndex).YLoc = pY;
%                     candLineStruct(newIndex).Indices = newComponentId;
%                     candLineStruct(newIndex).OldLine = 0;
%                     foundLineCentYs(end+1) = pY; %problem may be here?
%                     lineEndPoints(end+1,:) = [0,pY,imgWidth,pY];
%                     newIndex = newIndex+1;
%                     
%                 else
%                      %idk
% 
%                 end
%             end
%         end

-------

[pYs,pXs,val]=find(centroidImg.*ismember(centroidImg,ccsNotInLine));

        candLineStruct = struct('YLoc',{},...
                                'Indices',{},...
                                'OldLine',{});

        newIndex = 1;
        

        
        for ii = 1:size(pYs,1)
            %plot(pXs(ii),pYs(ii), 'r*');
            newComponentId = val(ii);
            [minDist,minIdx]=min(abs(foundLineCentYs-pYs(ii)));
            closestLineY = foundLineCentYs(minIdx);
            distance = abs(pYs(ii)-closestLineY);
            if distance > closeAvgDistMargin*avgDistance
                candLineStruct(newIndex).OldLine = 0;
            else
                candLineStruct(newIndex).OldLine = 1;
            end
            candLineStruct(newIndex).YLoc = pYs(ii);
            candLineStruct(newIndex).Indices = newComponentId;
            
            newIndex=newIndex+1;
        end
        
        %Categorizing newly found lines into the label image
        
        
        
        subset1Indx = [subset1.Index];
        subset1Pieces = [subset1.PiecesAmount];
        highestLabel = max(lineLabels(:));
        
        for ii = 1:length(candLineStruct)
            indicesInArea=[candLineStruct(ii).Indices];
            piecesInArea = histcounts(indicesInArea,'BinMethod','Integers');
            piecesInArea(piecesInArea==0)=[];
            uniqueComponentsInArea = unique(indicesInArea);
            %Remove value if at least half of corresponding block-centroids 
            %are not in area.
            indicesInArea(piecesInArea<(0.5*subset1Pieces(ismember(subset1Indx,indicesInArea))))=[];
            tmpLineImg = logical(labels).*ismember(labels,indicesInArea);
            prop = regionprops(tmpLineImg,'Centroid','Orientation');
            oldLine = candLineStruct(ii).OldLine;
            if oldLine~=0
                centroid = [lineStruct(:).Centroid];
                [~,minId]=min(centroid(1:2:end)-candLineStruct(ii).YLoc);
                newLabel = minId;
                %newLabel = oldLine;
                
            else
                highestLabel = highestLabel+1;
                newLabel = highestLabel;
                indexOfNewLine = length(lineStruct)+1;
                lineStruct(indexOfNewLine).SkewAngle = prop.Orientation;
                lineStruct(indexOfNewLine).Centroid = prop.Centroid;
            end
            highestLabel = highestLabel+1;
            lineLabels(ismember(labels,uniqueComponentsInArea))=newLabel;

        end
        


    %Old stuff
%     disp('Layout analysis...');
%     tic
%     l = layoutAnalyzer(preprocessedImage,...
%                        aoiXExpansionAmount,...
%                        aoiYExpansionAmount,...
%                        areaRatioThreshold,...
%                        rlsaRowThreshold ,...
%                        rlsaWordThreshold);
%     
%     aoiStruct = l.analyze;
%     toc
%     
% 	visualizeLayout(p.originalImage, aoiStruct, 3);
